
# **Программное средство реализации онлайн-сервиса для парусных туров**

Проект представляет собой онлайн‑сервис для организации и бронирования парусных туров. Система ориентирована на две ключевые роли: клиента, который выбирает и бронирует тур, и туроператора, который управляет предложениями и бронированиями.

Цели проекта:

- обеспечить удобный поиск и выбор туров по дате, цене и маршруту;

- автоматизировать процесс бронирования и оплаты;

- предоставить клиентам актуальную информацию и поддержку на всех этапах путешествия;

- упростить туроператорам управление турами, оплатами и обратной связью.

Основные возможности:

- каталог туров с фильтрацией и сортировкой;

- просмотр описаний, фотографий, маршрутов и отзывов;

- бронирование мест и онлайн‑оплата;

- уведомления и инструкции для подготовки к туру;

- управление заявками и платежами со стороны туроператора;

- сбор и анализ отзывов для улучшения качества услуг.


Клиент:
https://github.com/A-l-i-n-a-K/WindRoute-frontend.git
Сервер:
https://github.com/A-l-i-n-a-K/WindRoute-backend.git
---

## **Содержание**

1. [Архитектура](#Архитектура)
	1. [C4-модель](#C4-модель)
	2. [Схема данных](#Схема_данных)
2. [Функциональные возможности](#Функциональные_возможности)
	1. [Диаграмма вариантов использования(#Диаграмма_вариантов_использования)]
	2. [User-flow диаграммы](#User-flow_диаграммы)
3. [Детали реализации](#Детали_реализации)
	1. [UML-диаграммы](#UML-диаграммы)
	2. [Спецификация API](#Спецификация_API)
	3. [Безопасность](#Безопасность)
	4. [Оценка качества кода](#Оценка_качества_кода)
4. [Тестирование](#Тестирование)
	1. [Unit-тесты](#Unit-тесты)
	2. [Интеграционные тесты](#Интеграционные_тесты)
5. [Установка и  запуск](#installation)
	1. [Манифесты для сборки docker образов](#Манифесты_для_сборки_docker_образов)
	2. [Манифесты для развертывания k8s кластера](#Манифесты_для_развертывания_k8s_кластера)
6. [Лицензия](#Лицензия)
7. [Контакты](#Контакты)

---
## **Архитектура**

### C4-модель

Для описания архитектурных решений программного средства была использована нотация С4 mo del. Каждый последующий уровень детализирует предыдущий, включая четыре уровня абстракции: контекст, контейнеры, компоненты и классы. 
Контекстный уровень представления программного обеспечения показан ниже.

<img width="974" height="704" alt="image" src="https://github.com/user-attachments/assets/09a95a00-6368-450c-bb2f-9f7fadf34bf0" />

Контейнерный уровень представления архитектуры программного средства представлен ниже.

<img width="863" height="526" alt="image" src="https://github.com/user-attachments/assets/468799c3-e987-429d-a0cf-224d5fa3122f" />

Следующим уровнем представления архитектуры программного средства является компонентный. Он представлен ниже.

<img width="928" height="602" alt="image" src="https://github.com/user-attachments/assets/c464e7bf-39e2-42fc-9268-8550e2a17af2" />

Самым нижним уровнем представления архитектуры является кодовый. Кодовый уровень представления архитектуры представлен ниже.

<img width="953" height="401" alt="image" src="https://github.com/user-attachments/assets/f1ff3224-2087-4941-80fd-0b6e1c5f331b" />

Таким образом, было описано архитектурное решение с использованием нотации C4 model, рассмотрены контекстный, контейнерный, компонентный и кодовый уровни представления архитектуры программного средства.
Clean Architecture – это подход к проектированию программных систем, который направлен на создание гибких, масштабируемых и легко сопровождаемых приложений. Его суть заключается в строгом разделении ответственности между слоями и в том, что бизнес логика (ядро системы) не зависит от деталей реализации – фреймворков, баз данных, пользовательского интерфейса или внешних сервисов. Такая архитектура обеспечивает независимость от технологий, возможность замены интерфейсов и инфраструктуры без переписывания бизнес правил, а также высокую тестируемость.
В основе архитектуры онлайн сервиса для парусных туров лежит доменный слой, который описывает ключевые объекты и их поведение: User с ролью клиента, туроператора или администратора; Tour с маршрутом, датой начала, ценой и координатами; Booking с привязкой к пользователю и туру, статусом и датой создания. Здесь же находятся value объекты вроде Coordinates и SearchCriteria. Этот слой формулирует бизнес правила и ограничения, не зная, как именно данные будут храниться или отображаться.
Над ним расположен слой прикладных сценариев, где описаны конкретные действия системы. Каждый сценарий – это отдельный use case, который принимает входные данные, взаимодействует с сущностями и репозиториями, проверяет условия и возвращает результат. Например, сценарий бронирования проверяет доступность тура, создаёт запись и инициирует уведомление; сценарий поиска туров применяет фильтры и возвращает список подходящих маршрутов; сценарий регистрации создаёт нового пользователя и отправляет приветственное сообщение.
Слой адаптеров отвечает за связь бизнес логики с внешними системами. Здесь находятся контроллеры, принимающие запросы от React SPA и преобразующие их в команды или запросы к use case. Репозитории реализуют доступ к MySQL, сервисы интеграции работают с Google Maps API для отображения маршрутов и с Notification Service для отправки сообщений. DTO и мапперы обеспечивают преобразование данных между слоями, а презентеры формируют ответы для фронтенда.
На внешнем уровне находится инфраструктурный слой, где собраны конкретные технологии: React SPA для пользовательского интерфейса, Spring Boot для backend сервисов, MySQL для хранения данных,  Google Maps API для карт и геолокации, WebSocket для уведомлений в реальном времени. Этот слой можно заменить или модернизировать без изменения внутренней логики.





### Схема данных

<img width="974" height="979" alt="image" src="https://github.com/user-attachments/assets/e96de826-d561-4600-af23-a703bef427ca" />


---

## **Функциональные возможности**

### Диаграмма вариантов использования

<img width="957" height="735" alt="image" src="https://github.com/user-attachments/assets/c8cc28af-6e69-4b17-9aaa-49a6a3bdefe1" />
Диаграмма отражает взаимодействие двух основных акторов: Клиента и Туроператора.
Со стороны Клиента предусмотрены ключевые сценарии работы с сервисом. Пользователь может искать и выбирать туры, задавая параметры поиска, просматривать результаты и добавлять понравившиеся варианты в избранное. После выбора тура клиент переходит к бронированию: вводит персональные данные, количество участников, выбирает дополнительные услуги и может указать пожелания. В дальнейшем он имеет возможность отменить бронь. В личном кабинете клиент управляет своим профилем – редактирует данные и просматривает уведомления от системы. Также он получает доступ к истории бронирований: активные показывают предстоящие поездки, где можно отменить тур, скачать билет и посмотреть детали, а завершённые позволяют просмотреть детали и при необходимости повторить бронирование.
Туроператор работает с системой с другой стороны. Его основная задача – управление турами: создание новых предложений, редактирование и просмотр деталей существующих. Он обрабатывает клиентские заявки, подтверждает бронирования и формирует билеты. Кроме того, туроператор имеет доступ к отчётности: может создавать отчёты, выгружать их в удобных форматах Также предусмотрен просмотр сводных данных по клиентам, что помогает анализировать спрос и эффективность работы.

### User-flow диаграммы

Ниже представлен пользовательский сценарий работы клиента с онлайн сервисом парусных туров. Он отражает последовательность действий от входа в систему до поиска, бронирования и оплаты тура, а также показывает возможные развилки и варианты завершения процесса.

<img width="5883" height="5053" alt="Клиент" src="https://github.com/user-attachments/assets/30e0c9cc-7bd4-4a52-b655-4cd2f99afcdd" />

Клиент заходит в приложение. На главной странице он видит краткое описание сервиса, рекламные баннеры с актуальными турами и кнопку для входа или регистрации. Если пользователь новый, он проходит процедуру регистрации, указывая имя, адрес электронной почты, пароль и контактные данные. Уже зарегистрированный клиент входит в систему по логину и паролю, после чего сервис проверяет корректность введённых данных. Если данные неверны, система просит повторно ввести данные, если верны – открывает личный кабинет.
В личном кабинете клиент получает доступ к основным функциям: он может редактировать свой профиль, добавляя или изменяя личные данные, пароль и просматривать уведомления от системы, такие как напоминание об оплате, подтверждение бронирования и сообщения от туроператора.
Также клиент может просмотреть свою историю бронирований, как завершенных туров, так и активных бронирований. Для предстоящего тура пользователь может отменить бронь, скачать билет, оплатить тур, если он не был оплачен ранее, а также просмотреть детали тура. Для завершенных – просмотреть детали, повторно его забронировать и оставить отзыв.
Клиент может сразу перейти к поиску новых туров. При переходе на страницу туров, ему будут представлены все доступные. Для поиска он задаёт параметры – даты, маршрут, длительность, стоимость, количество участников и дополнительные услуги. Система формирует список доступных вариантов, из которого клиент выбирает подходящий тур. На странице выбранного тура он знакомится с описанием маршрута, фотографиями яхты и условий проживания, стоимостью и перечнем включённых услуг, а также с отзывами других участников. Если предложение его не устраивает, он продолжает искать подходящий, иначе может его забронировать или добавить в избранное.
При бронировании тура открывается форма бронирования, где клиент указывает количество участников, выбирает дополнительные услуги, такие как аренда снаряжения или питание, и может оставить специальные пожелания. Система проверяет корректность введённых данных, если данные некорректны просит повторить ввод, иначе переводит пользователя к этапу оплаты. Клиент выбирает удобный способ – банковскую карту, онлайн кошелёк или другой доступный вариант. Далее пользователь подтверждает оплату. При успешной оплате система сообщает об успешной оплате, а при ошибке уведомляет клиента и предлагает повторить попытку. Если клиент отказывается, тур помечается статусом «Ожидает оплаты». Если оплата не будет произведена в течении 24 часов, то клиент получает сообщение об отмене бронирования.
Дополнительно сервис позволяет сохранить тур в «Избранное» для будущего бронирования. В том же разделе он может просмотреть ранее сохраненные туры или удалить их оттуда. Завершая процесс, клиент выходит из программы.
Далее приведён пользовательский сценарий работы туроператора в онлайн сервисе. Он описывает шаги по управлению турами, обработке заявок клиентов, взаимодействию с системой уведомлений и формированию отчётности, что позволяет проследить ключевые бизнес процессы со стороны поставщика услуг.

<img width="6072" height="4232" alt="Туроператоры" src="https://github.com/user-attachments/assets/017f3fcc-c585-4abd-a526-965e1986fc4c" />

Туроператор заходит в приложение. На главной странице он выбирает вход для туроператора и вводит логин и пароль. Система проверяет корректность данных: если они неверны, оператору предлагается повторить ввод, если верны – открывается личный кабинет.
В личном кабинете туроператор получает доступ к основным функциям. Он может редактировать профиль компании, добавляя или изменяя контактные данные, описание, логотип и условия сотрудничества. Также в кабинете отображаются уведомления от системы: новые заявки клиентов, напоминания об оплате, сообщения и вопросы от пользователей.
Основной раздел работы туроператора – управление турами. При переходе на страницу система сразу показывает список всех созданных туров. Здесь оператор может просмотреть их, отфильтровать по датам или статусу, а также выполнить поиск. Далее он выбирает действие: добавить новый тур или работать с существующим. При добавлении открывается форма, где указываются маршрут, даты, стоимость, описание, фотографии и дополнительные услуги. После проверки корректности данных тур сохраняется как черновик, после он может опубликовать его в каталоге. Если он этого не делает, то тур остается в статусе «Черновик». При работе с существующим туром оператор может просмотреть его детали, внести изменения, заархивировать или удалить, если нет активных бронирований. Если изменения затрагивают уже подтверждённые заявки, система требует уведомить клиентов или согласовать корректировки.
Также туроператор обрабатывает заявки клиентов. Туроператор видит список всех заявок с указанием их статуса: новые, подтверждённые, оплаченные или отменённые. Для каждой заявки он может выбрать действие: подтвердить, отклонить или запросить уточнения. При подтверждении система проверяет соответствие условий. Если всё корректно, клиент получает уведомление и может оплатить тур. Если условия не соответствуют, оператор предлагает альтернативы, если клиент отказывается, то туроператор отклоняет заявку. После подтверждения система отслеживает оплату: при успешном платеже формируются документы, при отсутствии оплаты в течении 24 часов бронь отменяется и клиенту отправляется сообщение об отмене. При отклонении заявки туроператор указывает причину и отправляет уведомление клиенту.
Дополнительно туроператор имеет доступ к отчетности и аналитике. Здесь он получает три варианта работы с данными. Если необходимо подготовить документы, он выбирает выгрузку отчётов в формате PDF или Excel, чтобы сохранить их для внутреннего использования или передачи руководству. Если важна наглядность, оператор открывает визуализированные данные и видит графики и диаграммы, которые показывают динамику спроса, загрузку туров и финансовые показатели. Если же нужен быстрый доступ к цифрам, он просматривает таблицу основных метрик, где собраны ключевые показатели: количество заявок, процент оплаченных туров и выручка за период.
Завершая работу, туроператор выходит из системы, при этом все изменения сохраняются, а новые туры и обновлённые заявки становятся доступны клиентам.




---

## **Детали реализации**

### UML-диаграммы

<img width="847" height="782" alt="image" src="https://github.com/user-attachments/assets/caa50859-8b55-4454-b722-b89099a8369f" />

Когда клиент открывает страницу веб приложения, фронтенд отправляет запрос к контроллеру для получения списка доступных туров из таблицы tours базы данных, после чего отображает их пользователю. Клиент выбирает конкретный тур и даты, и фронтенд формирует POST запрос к контроллеру, который через сервис и репозиторий обращается к таблице tours, извлекает данные выбранного тура и возвращает их обратно на фронт для отображения формы бронирования. После заполнения формы с персональными данными, количеством участников и дополнительными услугами фронтенд отправляет POST запрос на создание бронирования. Контроллер передаёт данные в сервис, где выполняется проверка всех условий: доступность тура, наличие тура и корректность введённых данных. Если условия выполняются, сервис вызывает метод репозитория для сохранения, который формирует SQL операцию вставки в таблицу bookings и получает от базы подтверждение с идентификатором новой записи. Результат возвращается через все уровни обратно на фронт, который показывает клиенту подтверждение брони. Если же условия нарушены, сервис формирует отказ с указанием причины, контроллер возвращает JSON ответ с ошибкой, а фронтенд отображает сообщение об отказе пользователю. Таким образом, диаграмма отражает полный цикл взаимодействия: клиент работает с фронтендом, фронтенд через HTTP запросы взаимодействует с контроллером, контроллер делегирует бизнес логику сервису, а сервис через репозиторий обращается к конкретным таблицам базы данных – tours для получения информации о турах и bookings для сохранения бронирований.

<img width="973" height="1177" alt="image" src="https://github.com/user-attachments/assets/41d6c789-0285-4ed5-848b-9c71b8972a0c" />

Сначала клиент выбирает тур, заполняет форму бронирования и отправляет её в систему. Система принимает данные и проверяет условия: наличие свободных мест и корректность введённой информации. Если условия соблюдены, система сохраняет бронь в базе данных и уведомляет клиента, который получает подтверждение и переходит в состояние ожидания тура. Если условия не соблюдены, система определяет причину: при отсутствии мест она уведомляет клиента, и тот получает сообщение «Нет доступных мест», после чего может выбрать другой тур и повторить процесс; при ошибке данных система отправляет уведомление «Проверьте введённые данные», клиент получает сообщение об ошибке и имеет возможность исправить форму и снова отправить её.


<img width="974" height="390" alt="image" src="https://github.com/user-attachments/assets/26784238-ff9e-4ae6-9626-7f0a22b649f8" />
Диаграмма компонентов отражает целостную архитектуру решения и демонстрирует взаимодействие всех ключевых подсистем. На стороне клиента (Frontend) расположены модули пользовательского интерфейса – BookingUI, CatalogUI, ProfileUI, AuthUI и ReviewsUI, которые обеспечивают работу с бронированиями, каталогом туров и услуг, личным кабинетом, аутентификацией и отзывами. Все обращения к серверу выполняются через REST API по протоколу HTTP с использованием формата JSON и механизма авторизации JWT. Серверная часть (Backend) разделена на несколько логических блоков: сервисы (AuthService, BookingService, CatalogService, ReviewService), реализующие бизнес логику аутентификации, бронирований, управления турами и отзывами; контроллеры (AuthController, BookingController, TourController, ReviewController), принимающие запросы от клиента и делегирующие их обработку; обработчики команд и запросов (CQRS Handlers), которые реализуют принцип разделения операций чтения и записи, включая создание и отмену бронирований, получение информации о турах и управление отзывами; а также подсистема безопасности (SecurityConfig, JwtTokenProvider, JwtAuthenticationFilter, UserDetailsServiceImpl), обеспечивающая защиту всех вызовов и проверку прав доступа. Доступ к данным инкапсулирован в репозиториях (UserRepository, BookingRepository, TourRepository, ServiceRepository, ReviewRepository), которые взаимодействуют с реляционной базой данных. База данных содержит таблицы пользователей и ролей (users, user_roles), туров и услуг (tours, services, tour_services), бронирований (bookings, booking_services) и отзывов (reviews). Для асинхронного взаимодействия между сервисами используется брокер сообщений, через который BookingService публикует события о создании и отмене бронирований, CatalogService подписывается для обновления доступности туров, а ReviewService может использовать события для отправки уведомлений. 

<img width="783" height="389" alt="image" src="https://github.com/user-attachments/assets/82e0c5b1-c0f0-479e-8f40-f6232521ac19" />
На стороне клиента располагается Browser (браузер пользователя), который содержит статические ресурсы приложения: файл index.html, React компоненты и JS бандлы. Браузер получает эти ресурсы от фронтенд сервера и инициирует REST запросы к бэкенду.
Frontend Server развёрнут как сборка Vite/React и отвечает за отдачу клиенту статических файлов интерфейса. Он обслуживает запросы на загрузку приложения и перенаправляет обращения к серверу приложений.
Backend Server реализован на основе Spring Boot и развёрнут в виде JAR приложения. В его составе находятся REST контроллеры, сервисы (AuthService, BookingService, CatalogService, ReviewService), обработчики команд и запросов (CQRS Handlers), а также фильтры безопасности JWT. Этот сервер обрабатывает бизнес логику системы, обеспечивает авторизацию и аутентификацию пользователей, управляет бронированиями, турами и отзывами.
Database Server развёрнут на MySQL и содержит все основные таблицы предметной области: users, user_roles, bookings, booking_services, tours, tour_services, services, reviews. Доступ к базе данных осуществляется через репозитории с использованием JDBC.

### Спецификация API

Представить описание реализованных функциональных возможностей ПС с использованием Open API (можно представить либо полный файл спецификации, либо ссылку на него)

### Безопасность

В онлайн сервисе парусных туров безопасность реализована через систему аутентификации и авторизации, построенную на Spring Boot и Spring Security. Основная идея заключается в том, что каждый пользователь имеет роль – либо клиент, либо туроператор. Клиент может просматривать туры и оформлять бронирования, а туроператор управляет расписаниями и добавляет новые туры. Чтобы разграничить эти возможности, в базе данных хранится сущность пользователя с полями для email, хэша пароля, роли и дополнительной информации, которая требуется от туроператора при регистрации.
Класс User описывает модель пользователя. Роль хранится как перечисление Role, где возможны только два значения: CLIENT и OPERATOR. Это упрощает проверку прав доступа, так как система всегда знает, к какой категории относится конкретный пользователь.

@Entity
@Table(name = "users")
public class User {
  @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @Column(unique = true, nullable = false)
  private String email;

  @Column(nullable = false)
  private String passwordHash;

  @Enumerated(EnumType.STRING)
  private Role role;

  // Дополнительные поля для туроператора
  private String companyName;
  private String phoneNumber;
  private String description;

  private Boolean active = true;
}

public enum Role {
  CLIENT, OPERATOR
}
Для защиты паролей используется BCryptPasswordEncoder. Этот алгоритм специально создан для того, чтобы усложнить перебор паролей, так как он адаптивный и позволяет задавать стоимость вычислений. В конфигурации Spring Security мы подключаем этот энкодер и задаём правила доступа. Конфигурация отключает серверные сессии и переводит систему в stateless режим, где каждый запрос проверяется через JWT токен. Публичными остаются только эндпоинты аутентификации и просмотр списка туров, всё остальное требует авторизации.

@EnableWebSecurity
@EnableMethodSecurity
@Configuration
public class SecurityConfig {
  @Bean
  public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
  }

  @Bean
  public SecurityFilterChain filterChain(HttpSecurity http, JwtAuthFilter jwtAuthFilter) throws Exception {
    http.csrf(csrf -> csrf.disable())
        .sessionManagement(sm -> sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
        .authorizeHttpRequests(auth -> auth
          .requestMatchers("/auth/**").permitAll()
          .requestMatchers(HttpMethod.GET, "/tours/**").permitAll()
          .anyRequest().authenticated()
        )
        .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);
    return http.build();
  }
}

Здесь важно отметить, что используется собственный фильтр JwtAuthFilter, который проверяет токен в каждом запросе. Если токен валиден, он извлекает из него идентификатор пользователя и его роль, а затем устанавливает контекст безопасности. Это позволяет Spring Security автоматически применять правила доступа к методам и контроллерам.
Генерация токена реализована в сервисе JwtService. При успешной аутентификации создаётся токен, в котором записываются идентификатор пользователя и его роль. Срок жизни токена ограничен пятнадцатью минутами, что снижает риск его компрометации.

@Service
public class JwtService {
  private final String secret = System.getenv("JWT_SECRET");

  public String generateAccessToken(User user) {
    Instant now = Instant.now();
    return Jwts.builder()
      .setSubject(String.valueOf(user.getId()))
      .claim("role", user.getRole().name())
      .setIssuedAt(Date.from(now))
      .setExpiration(Date.from(now.plus(Duration.ofMinutes(15))))
      .signWith(Keys.hmacShaKeyFor(secret.getBytes()), SignatureAlgorithm.HS256)
      .compact();
  }
}

Контроллер аутентификации обрабатывает вход пользователя. Он принимает email и пароль, проверяет их корректность и при успешной проверке создаёт JWT токен, который возвращается клиенту.

@RestController
@RequestMapping("/auth")
public class AuthController {
  private final AuthenticationManager authManager;
  private final JwtService jwtService;

  @PostMapping("/login")
  public ResponseEntity<Map<String, String>> login(@RequestBody LoginRequest req, HttpServletResponse res) {
    Authentication auth = authManager.authenticate(
      new UsernamePasswordAuthenticationToken(req.getEmail(), req.getPassword())
    );
    User user = (User) auth.getPrincipal();

    String access = jwtService.generateAccessToken(user);
    return ResponseEntity.ok(Map.of("access_token", access, "token_type", "Bearer"));
  }
}

Разграничение доступа к бизнес операциям реализовано через аннотации @PreAuthorize. Это позволяет явно указать, какие роли имеют право выполнять определённые действия. Например, создание тура доступно только туроператору, а оформление бронирования – только клиенту.

@RestController
@RequestMapping("/tours")
public class TourController {
  @PostMapping
  @PreAuthorize("hasRole('OPERATOR')")
  public TourDto create(@RequestBody TourCreateDto dto, @AuthenticationPrincipal User user) {
    return /* создание тура */;
  }
}

@RestController
@RequestMapping("/bookings")
public class BookingController {
  @PostMapping
  @PreAuthorize("hasRole('CLIENT')")
  public BookingDto create(@RequestBody BookingCreateDto dto, @AuthenticationPrincipal User user) {
    return /* оформление брони */;
  }
}

Таким образом, система аутентификации и авторизации работает как связанный механизм: пользователь регистрируется и входит в систему, получает токен, который проверяется фильтром, а доступ к методам контролируется аннотациями. Туроператор при регистрации указывает дополнительные поля, которые позволяют системе связать его с конкретными турами и контактной информацией. Все данные передаются только по HTTPS, а чувствительные поля могут храниться в зашифрованном виде.


### Оценка качества кода

Используя показатели качества и метрики кода, оценить его качество

---

## **Тестирование**

### Unit-тесты

Представить код тестов для пяти методов и его пояснение

### Интеграционные тесты

Представить код тестов и его пояснение

---

## **Установка и  запуск**

Программное средство WindRoute предназначено для реализации он-лайн-сервиса бронирования парусных туров. Архитектура системы построена по трёхуровневой модели: 
‒	frontend – пользовательский интерфейс (React, TypeScript/JavaScript); 
‒	backend – бизнес‑логика и API (Java, Spring Boot); 
‒	database – хранение данных (MySQL).
Система поддерживает две роли:
1 	Клиент – просматривает туры, выбирает даты, оформляет бронирование.
2 	Туроператор – подтверждает бронирования, управляет турами, контролирует заявки.
В системе WindRoute реализован механизм регистрации пользователей, позволяющий как клиентам, так и туроператорам создавать собственные учётные записи. В зависимости от выбранной роли отображаются соответ-ствующие поля: клиенты вводят персональные данные для оформления бро-нирований, а туроператоры указывают информацию о компании и контактное лицо. После заполнения формы данные сохраняются в базе MySQL, и пользо-ватель получает возможность авторизоваться и работать в системе в рамках своей роли.
Для успешной установки и запуска программного средства необходимо наличие следующих компонентов:
– операционная система семейства Windows, Linux или macOS; 
– сервер базы данных MySQL; 
– веб-сервер ApacheTomcat; 
– среда разработки IntelliJ IDEA;
– Node.js и npm (Node Package Manager);
– совместимый с современными веб-технологиями веб-браузера, например, Google Chrome или Microsoft Edge; 
– Visual Studio Code;
– Java Development Kit.
Для установки разработанного средства приложения необходимо вы-полнить следующие шаги:
– установить и настроить IntelliJ IDEA;
– установить и настроить Visual Studio Code;
– установить и настроить Java Development Kit;
– установить и настроить Node.js;
– установить и настроить сервер приложений Apache Tomcat;
– установить и настроить сервер баз данных MySQL;
– установить и настроить разработанное программное приложения.
В поставляемый конечному пользователю дистрибутив входят следую-щие элементы:
– скрипт генерации пустой базы данных; 
– установочный пакет сервера баз данных MySQL; 
– установочный пакет веб-сервера ApacheTomcat; 
– установочный пакет IntelliJ IDEA;
– установочный пакет Visual Studio Code;
– установочный пакет Node.js;
– установочный пакет Java Development Kit;
– файл программного приложения с расширением «.exe».
Распаковка дистрибутива имеет место быть только в случае, если уста-новка программного приложения осуществляется в определенные системные директории операционной системы. Если распаковка дистрибутива осуществ-ляется в новую или создаваемую при установке дистрибутива директорию, то данный раздел руководства можно опустить.
Предполагается, что установка и запуск программного приложения не требуют распаковки дистрибутива в системные директории.
Для восстановления базы данных программного приложения из резерв-ной копии необходимо выполнить следующие шаги:
1 Для входа в консоль MySQL необходимо выполнить команду:

mysql -u root -p

Для создания пустой базы данных необходимо выполнить команду:

CREATE DATABASE windroute;

2 В случае удачного выполнения вышеуказанной команды будет созда-на база данных.
3 Для задания прав пользователю tomcat на свежесозданную базу дан-ных необходимо выполнить команду:

GRANT ALL PRIVILEGES ON windroute.* TO 'root'@'localhost';

4 Для выхода из консоли MySQL необходимо нажать операцию клавиш Сtrl+c.
5 Для выполнения скрипта из файла Windroute.txt необходимо выполнить команду (предполагается, что файл скрипта находится в папке C:\Users\Users_name):

mysql -u root -p fitquest < C:\Users\Users_name\ Windroute.txt

Если файл скрипта находится в другой папке, то следует изменить путь к данному файлу.
6 После успешного выполнения скрипта база данных «windroute» будет восстановлена.
Для корректной работы программного приложения необходимо внести изменения в файл application.properties, расположенном в файле программного приложения по адресу \src\main\resources\application.properties, выглядящим следующим образом:

spring.application.name= windroute -backend
spring.jpa.hibernate.ddl-auto=update
spring.datasource.url=jdbc:mysql://localhost:3306/windroute
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
springdoc.swagger-ui.path=/api-docs

В данном коде следует изменить логин и пароль пользователя (spring.datasource.username, spring.datasource.password) на соответствующий в базе данных. Также, необходимо заменить путь к данному файлу и его ресурсам в соответствии с размещением папки проекта на компьютере-установщике.
Для проверки работоспособности программного приложения необходимо:
– убедиться в том, что сервер MySQL запущен; 
– убедиться в том, что сервер приложений tomcat запущен; 
–.используя любой интернет браузер, перейти на сайт http://localhost:3000, где 3000 – это порт, указанный при установке Tomcat. 
В случае успеха откроется главная страница программного приложения.


---

## **Лицензия**

Этот проект лицензирован по лицензии MIT - подробности представлены в файле [[License.md|LICENSE.md]]

---

## **Контакты**

Автор: email
